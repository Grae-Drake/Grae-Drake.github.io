<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Grae</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Grae</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 24 May 2020 15:13:26 -0700</lastBuildDate>
    <image>
      <url>/images/icon_hu93b40ccc63f923d2d46da2367b778cd9_3377_512x512_fill_lanczos_center_2.png</url>
      <title>Grae</title>
      <link>/</link>
    </image>
    
    <item>
      <title>Project Euler Problem 2: Even Fibonacci numbers</title>
      <link>/post/euler_problem_2/</link>
      <pubDate>Sun, 24 May 2020 15:13:26 -0700</pubDate>
      <guid>/post/euler_problem_2/</guid>
      <description>&lt;p&gt;Our first, and certainly not our last, encounter with the Fibonacci Sequence on Project Euler. Before we dive into Problem 2 together take some time to chew on it yourself if you haven&amp;rsquo;t already. Did you find a solution? If so have you been able to improve or streamline your first one? If not do can you clearly describe to yourself what you&amp;rsquo;re stuck on?&lt;/p&gt;





  











&lt;figure id=&#34;figure-modern-mathematicians-just-arent-this-_imposing_-image-a-hrefhttpscommonswikimediaorgwikifileleonardo_da_pisajpgmediafileleonardo_fibonaccijpgwikipediaa&#34;&gt;



  &lt;img src=&#34;/img/Leonardo_Fibonacci.jpeg&#34; alt=&#34;&#34;  &gt;



  
  
  &lt;figcaption&gt;
    Modern mathematicians just aren&amp;rsquo;t this &lt;em&gt;imposing&lt;/em&gt;. Image: &lt;a href=&#39;https://commons.wikimedia.org/wiki/File:Leonardo_da_Pisa.jpg#/media/File:Leonardo_Fibonacci.JPG&#39;&gt;Wikipedia&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;the-straightforward-approach&#34;&gt;The Straightforward Approach&lt;/h2&gt;
&lt;p&gt;The most straightforward way to solve this problem is to generate every Fibonacci number below four million, then look at each one, check whether it&amp;rsquo;s even and add it to our total if it is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fibs = [1, 1]
while fibs[-1] + fibs[-2] &amp;lt; 4000000:
    fibs.append(fibs[-1] + fibs[-2])

evens = []
for n in fibs:
    if n % 2 == 0:
        evens.append(n)

print(sum(evens))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;saving-some-memory&#34;&gt;Saving Some Memory&lt;/h2&gt;
&lt;p&gt;The solution above works and runs plenty quick. We don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to simplify. But &lt;em&gt;can&lt;/em&gt; we? You might notice that we&amp;rsquo;re creating a pretty big list of fibonacci numbers. Is there a way we can avoid using all that memory? What if, instead of a list, we just kept track of the two most recent numbers and checked for evenness at the same time we generate each new number?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = 0
a = 1
b = 1
while a + b &amp;lt; 4000000:
    next = a + b
    a = b
    b = next
    
    if b % 2 == 0:
        result += b

print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;saving-some-lines&#34;&gt;Saving Some Lines&lt;/h2&gt;
&lt;p&gt;Mathematicians and programmers coming from other languages might get weirded out by an amazing Python feature called &lt;strong&gt;multiple assignment&lt;/strong&gt;. It lets us do things like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = &#39;ham&#39;
y = &#39;eggs&#39;

x, y = y, x

print(x)
&amp;gt;&amp;gt;&amp;gt; &#39;eggs&#39;
print(y)
&amp;gt;&amp;gt;&amp;gt; &#39;ham&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Multiple assignment lets us swap two variables in a single line and do other fun things with assigning to more than one variable at a time. Check out how we can use multiple assignment to compress our solution above in two places:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = 0
a, b = 1, 1
while a + b &amp;lt; 4000000:
    a, b = b, a + b
    if b % 2 == 0:
        result += b

print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is super useful and can make for much more concise code. Trey Hunter has a great 
&lt;a href=&#34;https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tutorial on multiple assignment&lt;/a&gt; if you want to learn more.&lt;/p&gt;
&lt;h2 id=&#34;skipping-odds&#34;&gt;Skipping Odds&lt;/h2&gt;
&lt;p&gt;In our solutions so far we&amp;rsquo;ve been calculating every fibonacci number and then checking if it&amp;rsquo;s even. What if we could just skip the fibonacci numbers we don&amp;rsquo;t want and just calculate the ones we need?&lt;/p&gt;
&lt;p&gt;Look at the sequence below. Do you see a pattern with even numbers?&lt;/p&gt;
&lt;p&gt;1, 1, &lt;strong&gt;2&lt;/strong&gt;, 3, 5, &lt;strong&gt;8&lt;/strong&gt;, 13, 21, &lt;strong&gt;34&lt;/strong&gt;, 55, 89, &amp;hellip;&lt;/p&gt;
&lt;p&gt;Every third term in the sample above is even. Can you see why it&amp;rsquo;s not just a coincidence and is true for the entire sequence?&lt;/p&gt;
&lt;p&gt;Is there a way to calculate &lt;em&gt;only&lt;/em&gt; the 3rd, 6th, 9th, etc. items so we don&amp;rsquo;t waste precious CPU cycles on lame odd numbers like &lt;code&gt;89&lt;/code&gt;? Yes.&lt;/p&gt;





  











&lt;figure id=&#34;figure-he-must-have-used-more-compute-than-absolutely-necessary&#34;&gt;



  &lt;img src=&#34;/img/computer_fire.gif&#34; alt=&#34;&#34;  &gt;



  
  
  &lt;figcaption&gt;
    He must have used more compute than absolutely necessary
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;I won&amp;rsquo;t run through the steps here, but you can start with the fibonacci series definition:&lt;/p&gt;
&lt;p&gt;$$ F_{n} = {\color{red}F_{n-2}} + \color{blue}F_{n-1} $$&lt;/p&gt;
&lt;p&gt;where $ F_{n} $ is the nth term in the sequence, and algebraically derive the equation:&lt;/p&gt;
&lt;p&gt;$$ F_{n} = {\color{red}F_{n-6}} + {\color{blue}F_{n-3}} + {\color{green}(3 * F_{n-3})} $$&lt;/p&gt;
&lt;p&gt;So normally to get the next term we add the previous two terms. For the next &lt;em&gt;even&lt;/em&gt; term we add the previous two &lt;em&gt;even&lt;/em&gt; terms, and then add the previous even term three more times. In code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Seed with first two even terms.
a, b = 2, 8
result = 10
while a + 4 * b &amp;lt; 4000000:
    a, b = b, a + b + (3 * b)
    result += b

print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;rsquo;s always nice when a more optimal algorithm &lt;em&gt;also&lt;/em&gt; makes for less code. However, we&amp;rsquo;ve lost some clarity compared to our previous solutions. It&amp;rsquo;s not clear from the code itself where the hard-coded &lt;strong&gt;magic numbers&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;8&lt;/code&gt;, and &lt;code&gt;10&lt;/code&gt; are coming from. 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Magic_number_%28programming%29#Unnamed_numerical_constants&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Magic numbers&lt;/a&gt; aren&amp;rsquo;t self-explanatory in the way named variables are and they can make a program harder to understand and maintain. That&amp;rsquo;s why I added a comment at the top: I did&amp;rsquo;t think the code alone made it obvious enough to you what it was doing.&lt;/p&gt;
&lt;h2 id=&#34;a-golden-solution&#34;&gt;A Golden Solution&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s get &lt;em&gt;real&lt;/em&gt; funky with it. Is there a way to calculate each term directly from the single term before it? For example, how could we look at &lt;code&gt;34&lt;/code&gt; and calculate &lt;code&gt;55&lt;/code&gt; without knowing or caring that the previous term was 21?&lt;/p&gt;
&lt;p&gt;Our buddy Fibonacci discovered way back in 1202 that the ratio between successive terms in the fibonacci sequence converges on $ \phi $, the &lt;strong&gt;golden ratio&lt;/strong&gt;. So if you take $ F_n $ and multiply it by $ \phi $ you get alllllmost $ F_{n+1} $. Using the example above you get:&lt;/p&gt;
&lt;p&gt;$$ 34 * \phi = 55.0131556175&amp;hellip; $$&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s &lt;em&gt;super&lt;/em&gt; close to the right answer: &lt;code&gt;55&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Multiply by $ \phi $ again and you get ~ &lt;code&gt;89&lt;/code&gt;, and multiply by $ \phi $ one last time to get ~&lt;code&gt;144&lt;/code&gt;. Each time we multiply by $ \phi $ we step to the next fibonacci number. We can take three steps at once by multiplying by $ \phi^3 $. More formally:&lt;/p&gt;
&lt;p&gt;$$ F_{n+3} \approx F_{n} * \phi^3 $$&lt;/p&gt;
&lt;p&gt;Ok this trick gets us an &lt;em&gt;approximate&lt;/em&gt; answer, but how do we turn that into an &lt;em&gt;exact&lt;/em&gt; answer? It turns out the approximation is so good and the error so small that you can just round the result to the nearest integer. That&amp;rsquo;s it:&lt;/p&gt;
&lt;p&gt;$$ F_{n+3} = \|(F_{n} * \phi^3)\| $$&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s code that up:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Define phi because it isn&#39;t predifined in the Python standard library.
phi = (1 + 5 ** 0.5) / 2
a = result = 2
while a * phi ** 3 &amp;lt; 4000000:
    a = round(a * phi ** 3)
    result += a

print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now ain&amp;rsquo;t that a shiny solution.&lt;/p&gt;
&lt;h2 id=&#34;almost-but-not-quite-an-analytic-solution&#34;&gt;Almost (But Not Quite) an Analytic Solution&lt;/h2&gt;
&lt;p&gt;This is a nice solution but it still relies on a &lt;code&gt;while&lt;/code&gt; loop to calculate items one by one. I can almost, but not &lt;em&gt;quite&lt;/em&gt; get to a direct calculation. The approximation, which was small enough between terms to round away, compounds in the approach I tried and is about 5% away from the right answer. If you see something I&amp;rsquo;m missing or know how to solve this &lt;em&gt;please let me know&lt;/em&gt;!. Here&amp;rsquo;s my not-quite-right stab at direct calculation.&lt;/p&gt;
&lt;p&gt;If we ignore rounding for now, we can write out the sequence of terms we generate above like this:&lt;/p&gt;
&lt;p&gt;$$ 2,\: 2\phi^3,\: 2\phi^6,\: 2\phi^9,\: 2\phi^{12},\: &amp;hellip; $$&lt;/p&gt;
&lt;p&gt;If you squint real hard, you can see that&amp;rsquo;s a 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Geometric_series&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;geometric series&lt;/a&gt;. It&amp;rsquo;s easier to see if we have a symbol for $ \phi^3 $. Let&amp;rsquo;s use $ r $:&lt;/p&gt;
&lt;p&gt;$$ 2r^0,\: 2r^1,\: 2r^2,\: 2r^3,\: 2r^4,\: &amp;hellip; $$&lt;/p&gt;
&lt;p&gt;where $ r = \phi^3 \approx{4.2360679775} $&lt;/p&gt;
&lt;p&gt;Since this is a geometric series we can use the 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Geometric_progression#Geometric_series&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;formula&lt;/a&gt; for the sum of the first $ n $ terms of a geometric series:&lt;/p&gt;
&lt;p&gt;$$ a(1-r^n)/{1 - r}  $$&lt;/p&gt;
&lt;p&gt;Where $ a $ is the start term (in our case: &lt;code&gt;2&lt;/code&gt;), $ r $ is the ratio between terms (in our case $ \phi^3 $ or about &lt;code&gt;4.2360679775&lt;/code&gt;), and $ n $ is the number of terms.&lt;/p&gt;
&lt;p&gt;All we&amp;rsquo;re missing now is $ n $. We can get that by taking the log base $ r $ of our limit (spoiler: it&amp;rsquo;s &lt;code&gt;11&lt;/code&gt;). Let&amp;rsquo;s code it up:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math
phi = (1 + 5 ** 0.5) / 2
r = phi ** 3
a = 2
n = 11
print((a * (1 - r ** n)) / (1 - r))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately the approximations, which were small enough to ignore last time, are now compounding. This attempt overshoots the right answer by about 5%. If you see something I&amp;rsquo;m overlooking please reach out and let me know!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Project Euler Problem 1: Multiples of 3 and 5</title>
      <link>/post/euler_problem_1/</link>
      <pubDate>Fri, 22 May 2020 16:12:38 -0700</pubDate>
      <guid>/post/euler_problem_1/</guid>
      <description>&lt;p&gt;This is a lovely 
&lt;a href=&#34;projecteuler.net/problem=1&#34;&gt;problem&lt;/a&gt; to start with. It has a straightforward brute-force loop solution as well as a nice analytic solution where you can calculate the solution directly without the need for much programming. And it&amp;rsquo;s 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Fizz_buzz#Programming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fizzbuzz&lt;/a&gt;! What a great way to dive in.&lt;/p&gt;
&lt;h2 id=&#34;who-is-this-for&#34;&gt;Who is this for?&lt;/h2&gt;
&lt;p&gt;A quick note: this series of posts is meant for people who already have a development environment set up and are familiar with the very basics of Python. If you&amp;rsquo;ve never written a line of Python before I recommend 
&lt;a href=&#34;https://learn.datacamp.com/courses/intro-to-python-for-data-science&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Data Camp&amp;rsquo;s Python introduction&lt;/a&gt; or another free Python 3 tutorial that covers the basics of &lt;strong&gt;variables&lt;/strong&gt;, &lt;strong&gt;basic types&lt;/strong&gt; (ints, floats, strings, booleans), &lt;strong&gt;operations&lt;/strong&gt;, &lt;strong&gt;lists&lt;/strong&gt;, &lt;strong&gt;dictionaries&lt;/strong&gt;, and &lt;strong&gt;functions&lt;/strong&gt;. If you&amp;rsquo;re an experienced programmer but new to Python check out the &amp;ldquo;official&amp;rdquo; 
&lt;a href=&#34;https://docs.python.org/3/tutorial/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python Tutorial&lt;/a&gt;. And if you&amp;rsquo;re comfy writing Python but don&amp;rsquo;t have a good local development environment set up yet check out 
&lt;a href=&#34;/&#34;&gt;Problem 0: Getting Started&lt;/a&gt; [TODO].&lt;/p&gt;
&lt;p&gt;Also, this is meant for people who enjoy solving or reading about 
&lt;a href=&#34;projecteuler.net&#34;&gt;Project Euler&lt;/a&gt; problems. PE has this to say about sharing solutions:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We hope that you enjoyed solving this problem. Please do not deprive others of going through the same process by publishing your solution outside of Project Euler. Members found to be spoiling problems beyond #100 will have their accounts locked (see note).&lt;/p&gt;
&lt;p&gt;Note: The rule about sharing solutions outside of Project Euler does not apply to the first 100 problems, as long as any discussion clearly aims to instruct methods, not just provide answers, and does not directly threaten to undermine the enjoyment of solving later problems. Problems 1 to 100 provide a wealth of helpful introductory teaching material and if you are able to respect our requirements, then we give permission for them to be discussed elsewhere.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I take PE&amp;rsquo;s requirements about sharing information seriously and hope you will too. I love that so much of the programming world happens in the open with public repos and such, but you won&amp;rsquo;t find my work on problems 101+ here, on GitHub, or anywhere else public.&lt;/p&gt;
&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;Ok, let&amp;rsquo;s talk about threes and fives. Before we analyze it together, 
&lt;a href=&#34;https://projecteuler.net/problem=1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;take a few minutes alone with Problem 1&lt;/a&gt;. Set up a Project Euler account if you haven&amp;rsquo;t already. Consider how you &lt;em&gt;might&lt;/em&gt; solve it. Take a stab at writing a solution before moving on. I&amp;rsquo;ll wait.&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;iterative-solutions&#34;&gt;Iterative Solutions&lt;/h2&gt;
&lt;p&gt;Great, you&amp;rsquo;re back. Let&amp;rsquo;s dive in. The most straightforward way to solve this problem is to look at every number from one to a thousand, test whether it&amp;rsquo;s divisible by 3 or 5, and add it to our running total if it is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = 0
integers = range(1, 1000)
for x in integers:
  if x % 3 == 0 or x % 5 == 0:
    result += x

print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this solution we initialize our result to &lt;code&gt;0&lt;/code&gt;, use a &lt;code&gt;for&lt;/code&gt; loop to iterate over every integer from &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;1000&lt;/code&gt;, test whether it&amp;rsquo;s divisible by &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt; using the modulo operator (&lt;code&gt;%&lt;/code&gt;) and add it to our &lt;code&gt;result&lt;/code&gt; variable if it is. Bam.&lt;/p&gt;
&lt;h3 id=&#34;using-list-comprehensions&#34;&gt;Using List Comprehensions&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;List comprehensions&lt;/a&gt; can be an elegant and &amp;ldquo;pythonic&amp;rdquo; way to solve problems. Here&amp;rsquo;s the same iterative solution above using a list comprehension rather than a loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(sum([x for x in range(1, 1000) if x % 3 == 0 or x % 5 == 0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now isn&amp;rsquo;t that short and sweet. I love list comprehensions. They can get ugly fast, and it&amp;rsquo;s possible to overuse them, but comprehensions excel in cases like this where you can express a few lines of procedural code as a single thought.&lt;/p&gt;
&lt;h3 id=&#34;a-more-functional-approach&#34;&gt;A More Functional Approach&lt;/h3&gt;
&lt;p&gt;Python isn&amp;rsquo;t known for being a naturally functional language, but it&amp;rsquo;s certainly possible to use it that way. You can use &lt;code&gt;filter()&lt;/code&gt; in place of the comprehension above:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(sum(filter(lambda x: x % 3 == 0 or x % 5 == 0, range(1, 1000))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at this approach next to the comprehension above it&amp;rsquo;s easy to see why the comprehension is more idiomatic: it just reads easier.&lt;/p&gt;
&lt;p&gt;And of course it&amp;rsquo;s no fun to talk about functional programming without contorting &lt;code&gt;reduce()&lt;/code&gt; into a solution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import reduce
print(reduce(
    lambda x, y: x + y if y % 3 == 0 or y % 5 == 0 else x,
    range(1, 1000),
    0
))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With Python 3 &lt;code&gt;reduce()&lt;/code&gt; is no longer a built-in function and instead needs to be imported from the &lt;code&gt;functools&lt;/code&gt; library. That makes me sad. I can understand why (a comprehension is &lt;em&gt;almost&lt;/em&gt; always more practical), but speaking as an apostle of 
&lt;a href=&#34;https://www.youtube.com/watch?v=Wl98eZpkp-c&amp;amp;feature=youtu.be&amp;amp;t=18&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Reduce, God of Parentheses&lt;/em&gt;&lt;/a&gt; I have to say I miss having it an my fingertips.&lt;/p&gt;
&lt;h1 id=&#34;analytic-solution&#34;&gt;Analytic solution&lt;/h1&gt;
&lt;p&gt;The iterative solutions above all rely on generating a list of integers, checking them one by one, and adding them up. That works just fine when you&amp;rsquo;re only counting to a thousand and you have modern computing resources at your fingertips. But things aren&amp;rsquo;t always so easy. What if we were solving this for all integers up to a quadrillion? What if we were working in an environment with limited memory or compute? What if we needed to run this solution gajillions of times every second?&lt;/p&gt;
&lt;p&gt;You might have heard a 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss#Anecdotes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;famous anecdote about Gauss&lt;/a&gt; and how as a young kid he summed the numbers from 1 to 100 in just a few seconds. He didn&amp;rsquo;t actually add all the numbers together, he recognized a pattern in the arithmetic progression 1, 2, 3, &amp;hellip; 99, 100 and used a formula instead. Specifically, you can &amp;ldquo;fold&amp;rdquo; the sequence and match pairs like 1 + 100, 2 + 99, 3 + 98, &amp;hellip; 49 + 52, 50 + 51. There are exactly 50 such pairs and each pair equals 101, so the total sum is 101 * 50 = 5,050.&lt;/p&gt;
&lt;p&gt;This approach works with &lt;em&gt;any&lt;/em&gt; arithmetic progression. We could sum all multiples of 5 below a hundred by &amp;ldquo;folding&amp;rdquo; the sequence 5, 10, 15, &amp;hellip; 95, 100 and getting 10 pairs that equal 105 for a total sum of 1,050.&lt;/p&gt;
&lt;p&gt;In general, the formula to calculate the 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Arithmetic_progression#Sum&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sum of an arithmetic progression&lt;/a&gt; is: &lt;code&gt;number_of_terms * (first_term + last_term) / 2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;How does this apply to our fizzbuzz problem? The integers we&amp;rsquo;re summing don&amp;rsquo;t form a nice arithmetic progression. And we can&amp;rsquo;t just add the sum of multiples of three to the sum of multiples of five, because that would double-count numbers like 15 and 30. And 45. And 60. See a pattern?&lt;/p&gt;
&lt;p&gt;The trick is in recognizing that we&amp;rsquo;re dealing with &lt;em&gt;three&lt;/em&gt; arithmetic progressions.  If we want the sum of all numbers that are a multiple of three &lt;em&gt;or&lt;/em&gt; a multiple of five, we can find that by adding &lt;code&gt;sum(multiples_of_three&lt;/code&gt; to &lt;code&gt;sum(multiples_of_five)&lt;/code&gt; and then &lt;em&gt;subtracting&lt;/em&gt; &lt;code&gt;sum(multiples_of_fifteen)&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def simple_arithmetic_series(step, limit):
    first = step
    count = (limit - 1) // step
    last = step * count
    return count * (first + last) / 2

multiples_of_3 = simple_arithmetic_series(3, 1000)
multiples_of_5 = simple_arithmetic_series(5, 1000)
multiples_of_15 = simple_arithmetic_series(15, 1000)

print(multiples_of_3 + multiples_of_5 - multiples_of_15)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;evil-optimization&#34;&gt;Evil optimization&lt;/h1&gt;
&lt;p&gt;The analytic solution involves a lot more typing and it isn&amp;rsquo;t as simple to read and understand, so why is it better?&lt;/p&gt;
&lt;p&gt;Well, it &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; better. There are tradeoffs between the analytic solution and the iterative solution. Neither is inherently better. Deciding which approach is better for you depends on your context.&lt;/p&gt;
&lt;p&gt;In the context of this specific problem, &lt;em&gt;the iterative solution works just fine&lt;/em&gt;. It&amp;rsquo;s faster to conceive and implement, it&amp;rsquo;s easier to understand, and less code is less chance for things to break. With our crazy strong computers and the small numbers involved the analytic solution is just a bunch of optimization that was (maybe) fun to do but doesn&amp;rsquo;t buy us anything valuable.&lt;/p&gt;
&lt;p&gt;This is an example of &lt;strong&gt;premature optimization&lt;/strong&gt;, and as Donald Knuth famously said, &amp;ldquo;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;premature optimization is the root of all evil&lt;/a&gt;&amp;quot;. Spending time optimizing things we don&amp;rsquo;t need to isn&amp;rsquo;t just a waste of time better spent elsewhere, it also makes our programs worse: harder to understand and maintain.&lt;/p&gt;
&lt;p&gt;That said, it&amp;rsquo;s easy to think of cases where the tradeoffs might play out the other way. What if we were working with much larger numbers? Try plugging in bigger numbers to the iterative and analytic solutions and watch where the difference in performance starts to get noticeable. My laptop struggles to run the iterative solution above about a hundred million. Even the world&amp;rsquo;s biggest supercomputer, 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Summit_%28supercomputer%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Summit&lt;/a&gt; doesn&amp;rsquo;t have enough memory to store a list of all integers up to a quadrillion. But my dinky laptop can calculate &lt;code&gt;simple_arithmetic_series(3, 1000000000000000)&lt;/code&gt; with no noticeable delay. With the right algorithm, my laptop can do something that&amp;rsquo;s literally impossible for the world&amp;rsquo;s best supercomputer.&lt;/p&gt;
&lt;p&gt;Those numbers seem ridiculous but spoiler alert: Project Euler is going to start throwing hefty numbers at us pretty quick. As we dig deeper performance, resources, and 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Computational_complexity_theory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;computational complexity&lt;/a&gt; are going to get critically important.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>❤️ Project Euler</title>
      <link>/post/heart_euler/</link>
      <pubDate>Thu, 21 May 2020 23:54:43 -0700</pubDate>
      <guid>/post/heart_euler/</guid>
      <description>&lt;p&gt;In 2012 I was a corporate lawyer at a big fancy firm. If you&amp;rsquo;d seen teenage me or college me you&amp;rsquo;d be understandably confused. Grae somehow ended up a lawyer? A corporate lawyer at a fancy firm? What? And if you know me today you might be similarly confused.&lt;/p&gt;
&lt;p&gt;My life as a corporate lawyer was short in part because of Project Euler.&lt;/p&gt;
&lt;p&gt;That winter Kelly, a law school classmate, shared an article with a group of us about this crazy new company called Dev Bootcamp. It trained people to be programmers. And actually got them jobs! Good ones!&lt;/p&gt;





  











&lt;figure id=&#34;figure-dbc-launched-the-coding-bootcamp-industry&#34;&gt;



  &lt;img src=&#34;/img/dbc.png&#34; alt=&#34;&#34;  &gt;



  
  
  &lt;figcaption&gt;
    DBC launched the coding bootcamp industry.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;By then we were starting our second year of practice. It wasn&amp;rsquo;t a great time. Graduating into the great recession meant a lot of us couldn&amp;rsquo;t land a firm job. And those who &lt;em&gt;did&lt;/em&gt; get hired were dealing with the tough reality of law firm life. A bunch of us had the same thought when we learned about coding bootcamps: &amp;ldquo;Holy shit, I wish this was a thing four years ago when I made the naive decision to go to law school.&amp;rdquo;&lt;/p&gt;





  











&lt;figure id=&#34;figure-aww-poor-white-collar-professional-photo-credit-ethan-sykes-on-unsplash&#34;&gt;



  &lt;img src=&#34;/img/gaze.jpg&#34; alt=&#34;&#34;  &gt;



  
  
  &lt;figcaption&gt;
    Aww, poor white collar professional. Photo credit: Ethan Sykes on Unsplash
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Most of the people who &lt;em&gt;would have&lt;/em&gt; done a bootcamp instead of law school couldn&amp;rsquo;t stomach eating the sunk cost to change careers. I was lucky: Stassia saw how unsatisfied I was. She said &amp;ldquo;If you aren&amp;rsquo;t happy you should quit; we&amp;rsquo;ll figure it out.&amp;rdquo; She&amp;rsquo;s done a lot of amazing things for me over the years, but giving me permission &amp;amp; encouragement to abandon a lucrative career is near the top of the list. She was still several years of training away from starting her own and mine was the only income. It was risky, but with her support I left biglaw.&lt;/p&gt;
&lt;p&gt;Tuition at DBC was I think like $12k. That&amp;rsquo;s a tiny fraction of the cost of my JD. Still, with my student debt and monthly loan payments we didn&amp;rsquo;t have the reserves or cashflow for that. So what could I do?&lt;/p&gt;
&lt;p&gt;Casting about the web for low cost options I ran into Hacker School (now 
&lt;a href=&#34;https://www.recurse.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Recurse Center&lt;/a&gt;). Seemed like a cool opportunity. Price was right. But I wasn&amp;rsquo;t qualified yet. I knew I didn&amp;rsquo;t have anywhere near enough programming experience to apply, but how much &lt;em&gt;was&lt;/em&gt; enough? I checked 
&lt;a href=&#34;https://web.archive.org/web/20130115173024/https://www.hackerschool.com/faq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;their FAQ&lt;/a&gt; and that&amp;rsquo;s where I found it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;How much programming experience do I need for Hacker School?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you&amp;hellip; solve 
&lt;a href=&#34;http://projecteuler.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Project Euler&lt;/a&gt; problems for fun&amp;hellip; you&amp;rsquo;re almost certainly a good fit for Hacker School.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Huh. Project Euler. What&amp;rsquo;s that? &lt;em&gt;Click&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I got hooked right away. Hooked bad. Being newly unemployed I spent my spring at The Wormhole drinking coffee and teaching myself Python by solving Project Euler problems. They scratched an itch I forgot I had. They were frustrating and impossible and clever and solving one felt &lt;em&gt;amazing&lt;/em&gt;. That silly green checkmark became the best part of my day.&lt;/p&gt;





  











&lt;figure id=&#34;figure-youre-good-enough-youre-smart-enough-and-doggone-it-people-like-you&#34;&gt;



  &lt;img src=&#34;/img/green_check.png&#34; alt=&#34;&#34;  &gt;



  
  
  &lt;figcaption&gt;
    You&amp;rsquo;re good enough, you&amp;rsquo;re smart enough, and doggone it, people like you!
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;By the time I interviewed at Thinkful I&amp;rsquo;d solved about 80 problems, averaging a solution every day or two, though some took much longer.&lt;/p&gt;
&lt;p&gt;Project Euler had a big impact on my work and my life. It made me excited to write code. It gave me the motivation to keep beating my head against the wall while I was learning. It lent me credibility during my interviews and helped me join Thinkful, where I successfully pivoted into tech and got paid to help others do the same. It drilled me, without me realizing, in data structures and algorithmic complexity before I knew what those were. And it reminded me how much I love math.&lt;/p&gt;
&lt;p&gt;So I want to talk about it here. I&amp;rsquo;ve held off on sharing my solutions or analysis because, well, Project Euler asked me not to. But now they let people talk about the first hundred problems. So let&amp;rsquo;s dive in and see how many of those we can cover.&lt;/p&gt;





  











&lt;figure &gt;



  &lt;img src=&#34;/img/lets_go.gif&#34; alt=&#34;&#34; width=&#34;75%&#34; &gt;




&lt;/figure&gt;

</description>
    </item>
    
  </channel>
</rss>
